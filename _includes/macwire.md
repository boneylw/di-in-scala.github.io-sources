
Manual DI isn’t of course a silver bullet. Manually writing new instance creation code for each class, using the correct parameters may be tedious.

That is where [MacWire](https://github.com/adamw/macwire) and the `wire` method can help. `wire` is a [Scala Macro](http://scalamacros.org/), which generates the new instance creation code. 

After using MacWire, the code becomes simpler:

````scala
object TrainStation extends App {
   lazy val pointSwitcher = wire[PointSwitcher]
   lazy val trainCarCoupler = wire[TrainCarCoupler]
   lazy val trainShunter = wire[TrainShunter]

   lazy val craneController = wire[CraneController]
   lazy val trainLoader = wire[TrainLoader] 
   lazy val trainDispatch = wire[TrainDispatch]

   lazy val trainStation = wire[TrainStation]

   trainStation.prepareAndDispatchNextTrain() 
} 
````

If a new dependency is added to a service or if the order of parameters changes, the object-graph wiring code doesn’t have to be altered; the macro will take care of that. Only when introducing a new service, it must be added to the list.

The new instance creation code is generated by `wire` at *compile time*, so if you compare the byte code generated by both examples, it will be identical. The generated code is type-checked in the usual way, so we keep the type-safety of the manual approach.

Usage of the `wire` macro can be mixed with creating new instances by hand; this may be needed if, as discussed earlier, creating a new instance isn’t that straightforward.

To access `wire`, you can either import the `com.softwaremill.macwire.MacwireMacros` object, or extend the `Macwire` trait. For details on how to integrate MacWire into your project, see the [GitHub page](https://github.com/adamw/macwire).

## How `wire` works

Given a class, the `wire` macro first inspects the primary constructor, to determine the dependencies needed. For each dependency it then looks for a value which is a subtype of the parameter’s type, in the enclosing method/class/object:

* first it tries to find a value declared in the enclosing method; if multiple values are found, a by-name match is attempted
* then it tries to find a unique value declared in the enclosing type
* finally it tries to find a unique value in parent types (traits/classes)

Here value can be either a `val`, `lazy val` or a no-parameter `def`, as long as the return type matches.

A compile-time error occurs if:

* there are multiple values of a given type in the enclosing type, or in parent types
* there is no value of a given type
 
*Note*: at the moment, the `wire` macro does not take into account definitions from within a method's body (only from the enclosing class/object/method parameters, as described above). For details see these issues: [#11](https://github.com/adamw/macwire/issues/11) and [#15](https://github.com/adamw/macwire/issues/15).

## Using implicit parameters

A similar effect to the one described above can be achieved by using implicit parameters and implicit values. If all constructor parameters are marked as `implicit`, and all instances are marked as `implicit` when the object graph is wired, the Scala compiler will create the proper constructor calls.

The class definitions then become:

````scala
class PointSwitcher()
class TrainCarCoupler()
class TrainShunter(
   implicit
   pointSwitcher: PointSwitcher, 
   trainCarCoupler: TrainCarCoupler)

class CraneController()
class TrainLoader(
   implicit
   craneController: CraneController, 
   pointSwitcher: PointSwitcher)

class TrainDispatch()

class TrainStation(
   implicit
   trainShunter: TrainShunter, 
   trainLoader: TrainLoader, 
   trainDispatch: TrainDispatch) {

   def prepareAndDispatchNextTrain() { ... }
}
````

And the wiring:

````scala
object TrainStation extends App {
   implicit lazy val pointSwitcher = new PointSwitcher
   implicit lazy val trainCarCoupler = new TrainCarCoupler
   implicit lazy val trainShunter = new TrainShunter

   implicit lazy val craneController = new CraneController
   implicit lazy val trainLoader = new TrainLoader

   implicit lazy val trainDispatch = new TrainDispatch

   implicit lazy val trainStation = new TrainStation

   trainStation.prepareAndDispatchNextTrain()
}
````

However, using implicits like that has two drawbacks. First of all, it is intrusive, as you have to mark the constructor parameter list of each class to be wired as `implicit`. That may not be desireable, and can cause the person reading the code to wonder why the parameters are implicit. 

Secondly, implicits are used in many other places in Scala for other, rather different purposes. Adding a large number of implicits as described here may lead to confusion. Still, such a style may be a perfect fit in some use-cases, of course!
